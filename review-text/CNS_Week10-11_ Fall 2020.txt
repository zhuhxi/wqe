Computer and Network Security
Dr. Chan Yeob Yeun


Week 10-11
Weekly Lecture Plan
     Wk          Contents             Cmt       Wk               Contents               Cmt
     1    Introduction                          9    Foundations of Network
                                                     Security II

     2    Foundations of           Tutorial     10   Network-Based Threats and
          Computer Security        Assig Plan        Attacks

     3    Identification and                    11   Network Security Protocols I
          Authentication I

     4    Identification and       Quiz 1       12   Network Security Protocols II   Quiz 3
          Authentication II
     5    Access Control                        13   Firewalls


     6    Modern Computer                       14   IDS / IPS                       Assig
          Attacks                                                                    Submit


     7    Malicious Code           Assig        15   Revision and Presentation
                                   Confirm


     8    Foundations of Network   Quiz 2       16   Exam
          Security I




P2
What is Network Security ?

     Physical     Datalink   Network      Transport Session Presentation Application

      Layer 1     Layer 2    Layer 3      Layer 4       Layer 5   Layer 6      Layer 7




 Confidentiality       Authentication     Integrity     Non-repudiation     Access Control


     Encryption         Authentication      Data           Digital
                        Exchange            Integrity      Signature        Access Control
Traffic Control

     Routing Control                                       Notarizations


         Trust           Security Label      Detection       Anti-Spam         Recovery




P3
Security Protocols



 Consider a variety of examples of security protocols.


 Consider examples based on all three types of cryptographic
 mechanism and all three types of freshness mechanism.




P4
Example 1 (time-stamp & encipherment)

     This example can be found in clause 5.1.1 of ISO/IEC 9798-2


             M1  Text2 || eK AB (TA || B || Text1)
                                                                 B
     A


         x || y denotes the concatenation of data item x and y
         K AB denotes a secret key shared by A and B

         eK AB denotes encryption using the shared secret key

          TA denotes a time-stamp generated by A

P5
Example 1 – discussion I


Consider four requirements for B:

     1. Can B be sure M1 was generated by A? Given the encryption
        function provides origin/integrity and Text1 enables Text2 to
        checked, then Yes.

     2. Can B sure M1 is fresh? Given TA is sufficient recent and no similar
        message has been received in current time window then Yes.




P6
Example 1 – discussion II


        3. Can B be sure M1 was intended for it? Since B is included in the
            enciphered string, Yes
        4. Is not applicable here.



     Note that 3 explains why the name of B is included in M1


     Use of Text1 and Text2 will depend on the application domain (Text1
     might be used for session key transfer).




P7
Example 2 (nonce & integrity mechanism)

     This example can be found in clause 5.1.2 of ISO/IEC 9798-4


                      M1  RB || Text1
                                                                      B
     A          M 2  Text3 || fK AB ( RB || B || Text2)



         fK AB denotes a cryptographic check value (the out of data
               integrity mechanism) computed using shared key


          RB denotes random nonce generated by B


P8
Example 2 – discussion I



 Consider four requirements: for B

     1. Can B be sure M2 was generated by A? Given the integrity
        mechanism is sound, then Yes.

     2. Can B sure M2 is fresh? Given RB is unpredictable then Yes.

     3. Can B be sure M2 was intended for it? Since B is included in the
        scope of the check value, Yes.




P9
Example 2 – discussion II



      4. Can B be sure that M2 is a reply to M1? Yes, because of the
          inclusion of RB



 If random nonce generation difficult (and a predictable counter and instead)
 then an alternative protocol which give s properties 2 and 4 can be produced
 by modifying protocol to include protection to M1.




P10
Example 2a (nonce & integrity mechanism)

This example can be found in clause 5.1.2 of ISO/IEC 9798-4




           M1  RB || Text1 || fK AB ( RB || Text1' )

                                                          B
  A         M 2  Text3 || fK AB ( RB || B || Text2)




P11
Example 2a - discussion



 Properties 2 and 4 are now provided even if RA is predictable, since the
 impersonating entity Eve cannot now persuade entity A to generate
 message M2 ‘ahead of time’, since Eve can no longer produce an
 acceptable message M1.


 Note that this is still a unilateral and not a mutual authentication protocol, i.e.
 A still cannot authenticate B, since A has no guarantees about the
 freshness of message M1.




P12
Example 3 (nonce & encipherment)

This example can be found in clause 5.2.2 of ISO/IEC 9798-2




                    M1  RB || Text1

           M 2  Text3 || eK AB ( RA || RB || B || Text2)     B
  A

          M 3  Text 5 || eK AB ( RB || RA || A || Text 4)




P13
Example 3 – discussion I



Consider four requirements for A:

      1. Can A be sure M1 and M3 were generated by B? A can check M3
         because of the encipherment. Checking M1 is more difficult; however
         A can reason that B would not have sent M3 unless it was B who sent
         message M1, and hence we have “Yes”

      2. Can A be sure M1 and M3 are fresh? Given RA is unpredictable then
         A can check freshness of M3, and hence M1 (since M3 include RB) –
         so Yes




P14
Example 3 – discussion II



      3. Can A be sure that M1 and M3 were intended for it? A can check
          that M3 is a reply to M2 and hence M3 must be for A. Thus, M1
          was also for A (since M3 includes RB) – so “Yes”.
      4. Can A be sure that M3 was a reply to M2? Yes, because of the
          inclusion of RA and RB.




P15
Example 3 – discussion III


B requirements are:

      1. Can B be sure M2 was generated by A? Yes, because of
         encipherment.
      2. Can B be sure M2 is fresh? Yes, because of inclusion of RB (RB must
         be unpredictable)
      3. Can B be sure M2 is intended for it? Yes, because of the inclusion of
         the name B.
      4. Can B be sure that M2 is reply to M1? Yes, because of the inclusion of
         RB.


  If generating random nonces is difficult, then a modified protocol can be used
  (as in Example 2a this will involve cryptographically protecting the first
  message)



P16
Example 4 (time-stamp & integrity mechanism)

  This example can be found in clause 5.2.1 of ISO/IEC 9798-4


            M1  TA || Text2 || fKAB (TA || B || Text1)
      A                                                               B
           M 2  TB || Text4 || fKAB (TB || A || Text3)

 Note that, in order for A and B to perform their checks, A and B must have the
 means to obtain the data strings Text3 and Text1 respectively.
 One possibility is that Text4 (Text2) contains a copy of Text3 (Text1), perhaps
 in enciphered form. Another possibility is that A and B can predict what the
 strings look like in advance.
 Text1-Text4 are data strings, whose use will depend on the application


P17
Example 4 – discussion I

Consider four requirements for A:

      1. Can A be sure M2 was generated by B? Given that integrity
         mechanism is sound then “Yes”

      2. Can A be sure M2 is fresh? Given TB is sufficiently recent and what no
         similar message has been received in the current time window – “Yes”

      3. Can A be sure that M2 is intended for it? “Yes”, because of the
         inclusion of A’s name in M2.




P18
Example 4 – discussion II



      4. Can A be sure that M2 was a reply to M1? Not necessary!
          There is nothing to link the two messages together

      Property 4 can be guaranteed by including an identifier in M1
      (Text1) and M2 (Text2)




P19
Example 4 – discussion III


Four requirements for B:


      1. Can B be sure M1 was generated by A? Given that the integrity
         mechanism is sound then “Yes”

      2. Can B be sure M2 is fresh? Given TA is sufficient recently and no similar
         message has been received in current time window – “Yes”

      3. Can B be sure M1 is intended for it? Yes, because of the inclusion of the
         name B.

      4. Does not apply




P20
Example 5 (time-stamp & signature)

  This example can be found in clause 5.2.1 of ISO/IEC 9798-3


          M1  TA || Text2 || sS A (TA || B || Text1)
      A                                                              B
            M 2  TB || Text4 || sS B (TB || A || Text3)

 SA and SB are the private signature keys of A and B respectively
 sSA denotes the signature function computed using private key SA

 Note that, in order for A and B to perform their checks, A and B must
 have the means to obtain the data strings Text3 and Text1 respectively.




P21
Example 5 – discussion



 The analysis of this protocol is very similar to that Example 4.


 Note that this means that, just like in Example 4, property 4 is not
 automatically satisfied




P22
Example 6 (nonce & signature)

  This example can be found in clause 5.2.2 of ISO/IEC 9798-3



                          M1  RB || Text1

           M 2  RA || Text3 || sS A ( RA || RB || B || Text2)
      A                                                          B

             M 3  Text 5 || sS B ( RB || RA || A || Text 4)




P23
Example 6 - discussion


 The analysis is very similar to Example 3.


 As with Example 3, RA needs be unpredictable, although RB
 does not seem to need to be.




P24
6 Comparisons and verification



 Consider relative merits of different techniques


 Possible extra properties required from authentication protocols.


 Because of difficulty in designing sound protocols, many formal
 techniques devised to try and analyse protocols




P25
Time-stamps vs. Nonces



 Advantages of time-stamps:
  Less message (typically one less),
  Fits well to client-server model (e.g. RPC)


  Disadvantages of time-stamps:
  Need for synchronise clocks (and log of recently received messages),
  Problems with property 4, i.e relating message of protocol together




P26
Linking messages


 Why do we want property 4? The need for this property depends on the
 application of the authentication protocol. If the protocol is used for:
  Time synchronise, or Database query protection, then linking of a
  “request” message to a “response” message is needed (to prevent a
  malicious interceptor “shuffling” responses to requests issued within a
  short time of one another).


 To address this problem, time-stamp protocols can use a “transaction ID”
 to achieve this linking of a request to a reply




P27
Summary


A possible model for the use of authentication protocols based on
the two basic types of “freshness” mechanism is as follows”:

 Use random or encrypted nonce protocols for time synchronisation,
 Use time-stamp based protocols for secure distributed applications, with
 transaction IDs if necessary to line messages.




P28
Extra properties


Proposed list of four desirable properties for an authentication protocol
is certainly not definitive.


Some specialised applications of authentication protocols extra
properties may be needed.


One possible additional property:
 5 After A(B) receives Mi then A(B) can be sure that B(A) knows the
 plaintext version of any enciphered data included in Mi.

Reason for this is illustrated by an X.400-1988 problem




P29
Part of X.400 protocol

  This example can be found in clause 5.1.1 of ISO/IEC 9798-3




        TA || B || Text2 || ePB (Text2) || sS A (TA || B || Text1 || ePB (Text2))
 A                                                                                  B


           This message use both public key encryption and a digital
           signature algorithm.
           The Text 2 field is meant to be used for confidential data


       TA denotes a time-stamp generated by A




P30
Discussion I



Note that this protocol involves signing enciphered data – generally
accepted to be bad practice. In general, it is always better to sign
data prior to encipherment


Suppose A wants to make an enquiry of public database B (the
database is public but query is private)


A puts query in data string Text2.




P31
Discussion II


C intercepts message and constructs new message with same Text1 and
ePB(Text2) but with new signature


B responds to C, and C can deduce A’s confidential query from the
response!


Problem is that property 5 is not provided




P32
Keying requirements


Protocols based on symmetric cryptography (enchipherment or data
integrity mechanism) need a shared secret between A and B.


Digital signature based protocols need A and B to have a trusted
copy of each other’s verification key.


Look at these different keying requirements in turn.




P33
Symmetric cryptography protocols


 Assume there is a trusted third party with whom both A and B share a
 secret.


 The (on-line) trusted third party (TTP) co-operates to enable A and B
 to authenticate one another.


 Requires more elaborate protocols.




P34
    Example 7 (time stamp & encipherment)


      This example can be found in clause 6.1 of ISO/IEC 9798-2

                                          TTP

M1  RA || B || Text1

                      M 2  Text4 || eK AT ( RA || K AB || B || Text3) || eKBT (TTP || K AB || A || Text2)



             M 3  Text 6 || eK BT (TTP || K AB || A || Text 2) || eK AB (TA || B || Text 5)
     A
                                                                                            B
                      M 4  Text8 || eK AB (TB || A || Text7)

    P35
     Example 8 (nonce & encipherment)

       This example can be found in clause 6.2 of ISO/IEC 9798-2


                                                TTP
M 2  R' A || RB || B || Text2



                            M 3  Text 5 || eK AT ( R' A || K AB || B || Text 4) || eK BT ( RB || K AB || A || Text 3)




                                          M1  RB || Text1
       A
            M 4  Text7 || eKBT ( RB || K AB || A || Text3) || eK AB ( RA || RB || B || Text6) B

                         M 5  Text 9 || eK AB ( RB || RA || Text 8)
     P36
Kerberos - Introduction


 Kerberos is a TTP-aided authentication protocol, closely related to
 Example 7.

 Devised as part of Project Athena at MIT.

 Designed to provide means to authenticate workstation users (clients) to
 servers (and vice versa)

 Uses symmetric encipherment and a Manipulation Detection Code (MDC).

 Kerberos is widely integrated into versions of the Unix OS, and code
 implementing the protocol is available on the Internet.




P37
Kerberos - TTPs


Kerberos makes use of two types of TTP:
 An authentication server (AS), and
 A ticket-granting server (TGS).

User has a long-term shared secret key with the AS, which then sets up a short
term shared secret key with the TGS.


The TGS is then involved in setting up shared session keys between client and
server




P38
Kerberos – motivation


Idea of having two TTPs is that a user only needs load his/her long-term secret
key into the work-station for the minimum time.


Once the short-term secret key is established (with TGS) the long-term secret
key can be erased from the workstation.


This minimises the risk of exposure of the long-term secret key




P39
 Example 9 (Kerberos protocol)

     This example can be found in clause 6.1 of ISO/IEC 9798-2


                                   TGS(TTP)
 AS


M1                M3
           M2
                         M4

       C                               M5                          S
     (Client)
                                                                 (Server)

                                       M6

 P40
Kerberos – message formats

M 1 (C  AS )  C || TG || times || N C
M 2 ( AS  C )  C || eK AST ( KCT || C || times ) || eK ASC ( KCT || times || NC || TG )
M 3 (C  TGS )  S || times || N 'C || eK AST ( K CT || C || times ) || eKCT (C || T1 )
M 4 (TGS  C )  C || eKTS ( KCS || C || times ) || eKCT ( KCS || times || N 'C || S )
M 5 (C  S )  eKTS ( K CS || C || times ) || eKCS (C || T2 )
M 6 ( S  C )  eKCS (T2 )
       K AST is a secret key shared by the AS and TGS
       K ASC is a secret key shared by the AS and C
       K TS is a secret key shared by the TGS and S
       K CTis a secret key shared by the C and TGS
       K CS is a secret key shared by the C and S
   timesdenotes a specified time interval (start and end time) – it is used to
            limit the validity of a key


 P41
Digital signature protocols


Need for trust instead of shared secret


Public verification keys can be certified by applying the digital
signature of a Trusted Third Party (TTP).


Result (public key + entity name + expiry date + TTP signature on
three items) called a certificate.




P42
Using certificates

To check a certificate signed by a TTP requires a trusted copy of
the TTP’s public verification key.

If two entities have certificates signed by different TTPs, then a
cross-certificate is needed (i.e. one TTP’s public verification key
signed by the other TTP).

Leads to notion of certification paths, i.e. sequence of cross-
certificates with the subject of one certificate being the signer of
the next certificate in the sequence.




P43
Key Distribution


One very important application of authentication protocol is during
connection establishment.

Can be used to set up session key(s) to protect data transferred during
connection lifetime.

Keys can be transferred by inclusion in data string elements of protocol
messages.

Note that, in some applications, property 5 is needed, i.e. the recipient of
an enciphered key wishes to be sure that the sender actually knows the
plaintext key, since the key is to be used subsequently to guarantee the
origin of data.




P44
Example 10

  This example can be found in clause 5.3 of ISO/IEC 11770-2



              M1  Text2 || eK AB (TA || B || SK AB )                B
      A


      This protocol has been derived in a very simple way from the protocol
      of Example 1. The Text1 field has been replaced with a session key
      SKAB, to be used by A and B in subsequent secure communications.


      Note that protocol property 5 is guaranteed since A Knows the key KAB




P45
Example 11

This example can be found in clause 5.6 of ISO/IEC 11770-2

                                M1  RB

                   M 2  eK AB ( RA || RB || B || FA )                    B
  A
                     M 3  eK AB ( RB || RA || FB )

 This protocol is based on Example 3. Text1, Text3 and Text5 are not used.
 Text2 and Text4 have been replaced by keying material fields FA and FB,
 which can be combined to form a session key for use by A and B


 Note that protocol property 5 is guaranteed since A knows the key KAB.


P46
Summary

There are four basic properties and one extra property for the protocol
requirements. A /(B) wants to be sure that”


 M2, M4 /(M1, M3), … were all sent by B / (A) (as received),
 M2, M4 /(M1, M3),… are “fresh”, i.e. not replays of old messages
 M2, M4 /(M1, M3),… were intended for A / (B), not for any other
 entity, and
 M2, M4 /(M3, M5),… were only generated by B / (A) after M1, M3
 /(M2, M4),… (respectively) were received correctly.

 After A/(B) receives Mi then A/(B) can be sure that B/(A) knows
 the plaintext version of any enciphered data included in Mi.




P47
